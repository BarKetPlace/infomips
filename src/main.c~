#include <string.h>
#include <stdio.h>
#include <stdlib.h>



#include "mem.h"
#include "notify.h"
#include "bits.h"
#include "formats.h"
#include "types.h"
#include "syms.h"
#include "section.h"


#include "../include/reg.h"


// On fixe ici une adresse basse dans la mémoire virtuelle. Le premier segment
// ira se loger à cette adresse.
#define START_MEM 0x3000
// nombre max de sections que l'on extraira du fichier ELF
#define NB_SECTIONS 4

// nom de chaque section
#define TEXT_SECTION_STR ".text"
#define RODATA_SECTION_STR ".rodata"
#define DATA_SECTION_STR ".data"
#define BSS_SECTION_STR ".bss"


// Fonction permettant de verifier si une chaine de caracteres
// est bien dans la liste des symboles du fichier ELF
// parametres :
// 		name : le nom de la chaine recherchée
//  symtab : la table des symboles
//
// retourne 1 si present, 0 sinon
int is_in_symbols(char* name, stab symtab) {
    int i;
    for (i=0; i<symtab.size; i++) {
        if (!strcmp(symtab.sym[i].name,name)) return 1;
    }
    return 0;
}

// Cette fonction calcule le nombre de segments à prevoir
// Elle cherche dans les symboles si les sections predefinies
// s'y trouve
// parametres :
//  symtab : la table des symboles
//
// retourne le nombre de sections trouvées

unsigned int get_nsegments(stab symtab,char* section_names[],int nb_sections) {
    unsigned int n=0;
    int i;
    for (i=0; i<nb_sections; i++) {
        if (is_in_symbols(section_names[i],symtab)) n++;
    }
    return n;
}


// fonction permettant d'extraire une section du fichier ELF et de la chargée dans le segment du même nom
// parametres :
//   fp         : le pointeur du fichier ELF
//   memory     : la structure de mémoire virtuelle
//   scn        : le nom de la section à charger
//   permission : l'entier représentant les droits de lecture/ecriture/execution
//   add_start  : l'addresse virtuelle à laquelle la section doit être chargée
//
// retourne 0 en cas de succes, une valeur non nulle sinon
int elf_load_section_in_memory(FILE* fp, mem memory, char* scn,unsigned int permissions,unsigned long long add_start) {
    byte *ehdr    = __elf_get_ehdr( fp );
    byte *content = NULL;
    uint  textsz  = 0;
    vsize sz;
    vaddr addr;

    byte *useless = elf_extract_section_header_table( ehdr, fp );
    free( useless );

    if ( NULL == ehdr ) {
        WARNING_MSG( "Can't read ELF file" );
        return 1;
    }

    if ( 1 == attach_scn_to_mem(memory, scn, SCN_ATTR( WIDTH_FROM_EHDR( ehdr ), permissions ) ) ) {
        WARNING_MSG( "Unable to create %s section", scn );
        free( ehdr );
        return 1;
    }

    content = elf_extract_scn_by_name( ehdr, fp, scn, &textsz, NULL );
    if ( NULL == content ) {
        WARNING_MSG( "Corrupted ELF file" );
        free( ehdr );
        return 1;
    }

    switch( WIDTH_FROM_EHDR(ehdr) ) {
    case 32 :
        sz._32   = textsz/*+8*/; /* +8: In case adding a final sys_exit is needed */
        addr._32 = add_start;
        break;
    case 64 :
        sz._64   = textsz/*+8*/; /* +8: In case adding a final sys_exit is needed */
        addr._64 = add_start;
        break;
    default :
        WARNING_MSG( "Wrong machine width" );
        return 1;
    }

    if ( 1 == fill_mem_scn(memory, scn, sz, addr, content ) ) {
        free( ehdr );
        free( content );
        WARNING_MSG( "Unable to fill in %s segment", scn );
        return 1;
    }

    free( content );
    free( ehdr );

    return 0;
}

// fonction affichant les octets d'un segment sur la sortie standard
// parametres :
//   seg        : le segment de la mémoire virtuelle à afficher

void print_segment_raw_content(segment* seg) {
    int k;
    int word =0;
    if (seg!=NULL && seg->size._32>0) {
        for(k=0; k<seg->size._32; k+=4) {
            if(k%16==0) printf("\n  0x%08x ",k);
            word = *((unsigned int *) (seg->content+k));
            FLIP_ENDIANNESS(word);
            printf("%08x ",	word);
        }
    }
}


int main(int argc, char* argv[])
{
	FILE* felf;
	segment* seg=NULL;
	mem memory;  // memoire virtuelle, c'est elle qui contiendra toute les données du programme
	 unsigned int next_segment_start = START_MEM; // compteur pour designer le début de la prochaine section
	 int i,j;
	//Info machine
	 unsigned int type_machine;
	 unsigned int endianness;   //little ou big endian
	 unsigned int bus_width;    // 32 bits ou 64bits
	 //Table des symboles
	 stab symtab= new_stab(0);
	 //Sections possibles
	 char* section_names[NB_SECTIONS]= {TEXT_SECTION_STR,RODATA_SECTION_STR,DATA_SECTION_STR,BSS_SECTION_STR};
	 unsigned int segment_permissions[NB_SECTIONS]= {R_X,R__,RW_,RW_};


	if ( argc != 2 )
	{
		printf("Usage: %s <fichier elf> \n", argv[0]);
		return 1;
	}


	if ( (felf = fopen(argv[1], "r")) == NULL  )
	{
		printf("-------->  /!\ Impossible d'ouvrir %s <--------\n", argv[1]);
		return 1;
	}

	if (!assert_elf_file(felf)) //Le fichier est il un fichier elf
	{
		printf("file %s is not an ELF file", argv[1]);
		return 1;
	}


	//On récupère les informations sur la machine
	elf_get_arch_info(felf, &type_machine, &endianness, &bus_width);
	// et des symboles
	elf_load_symtab(felf, bus_width, endianness, &symtab);



	uint nsegments=0;
	nsegments = get_nsegments(symtab,section_names,NB_SECTIONS);

	  // allouer la memoire virtuelle
	    memory=init_mem(nsegments);

	    // Ne pas oublier d'allouer les differentes sections
	    j=0;
	    for (i=0; i<NB_SECTIONS; i++) {
	        if (is_in_symbols(section_names[i],symtab)) {
	            elf_load_section_in_memory(felf,memory, section_names[i],segment_permissions[i],next_segment_start);
	            next_segment_start+= ((memory->seg[j].size._32+0x1000)>>12 )<<12; // on arrondit au 1k suppérieur
	//            print_segment_raw_content(&memory->seg[j]);
	            j++;
	        }
	    }
	
	
	//Chargement des registres
	registre* reg = alloue_reg();
	
	if (!init_reg(reg)) return 0;
	

	if ( !init_stack(memory,reg, nsegments) )
	{
		ERROR_MSG("Probleme chargement de la pile\n"); return 0;
	}
	
	print_mem( memory );
	print_tab_reg(reg);
	printf("\n\n");
	del_mem(memory);
	del_stab(symtab);
	fclose(felf);
	free(reg);
}
