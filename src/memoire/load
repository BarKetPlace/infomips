
int main(int argc, char* argv[])
{
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Chargement de la mémoire /////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
	FILE* felf;
	segment* seg=NULL;
	mem memory;  // memoire virtuelle, c'est elle qui contiendra toute les données du programme
	 unsigned int next_segment_start = START_MEM; // compteur pour designer le début de la prochaine section
	 int i,j;
	//Info machine
	 unsigned int type_machine;
	 unsigned int endianness;   //little ou big endian
	 unsigned int bus_width;    // 32 bits ou 64bits
	 //Table des symboles
	 stab symtab= new_stab(0);
	 //Sections possibles
	 char* section_names[NB_SECTIONS]= {TEXT_SECTION_STR,RODATA_SECTION_STR,DATA_SECTION_STR,BSS_SECTION_STR};
	 unsigned int segment_permissions[NB_SECTIONS]= {R_X,R__,RW_,RW_};
	registre* reg;



	//Ouverture du fichier elf
	if (   (felf = fopen(argv[1], "r") ) == NULL  )
	{
		printf(" ------->   Impossible d'ouvrir %s <--------\n", argv[1]);
		return 1;
	}
	//On vérifie que le nombre d'argument est correct et que le fichier est bien un fichier elf
	if ( !check_appel(argc, argv,felf) ) return 1;

	
	//On récupère les informations sur la machine
	elf_get_arch_info(felf, &type_machine, &endianness, &bus_width);
	// et des symboles
	elf_load_symtab(felf, bus_width, endianness, &symtab);


	uint nsegments=0;
	nsegments = get_nsegments(symtab,section_names,NB_SECTIONS);

	  // allouer la memoire virtuelle
	    memory=init_mem(nsegments);

	    // Ne pas oublier d'allouer les differentes sections
	    j=0;
	    for (i=0; i<NB_SECTIONS; i++) {
	        if (is_in_symbols(section_names[i],symtab)) {
	            elf_load_section_in_memory(felf,memory, section_names[i],segment_permissions[i],next_segment_start);
	            next_segment_start+= (((memory)->seg[j].size._32+0x1000)>>12 )<<12; // on arrondit au 1k suppérieur
	//            print_segment_raw_content(&memory->seg[j]);
	            j++;
	        }
	    }
	
	
	//Chargement des registres
	reg = alloue_reg();
	
	if (!init_reg(reg)) return 0;
	

	if ( !init_stack(memory,reg, nsegments) )
	{
		ERROR_MSG("Probleme chargement de la pile\n"); return 0;
	}

	//print_mem( memory );
	//print_tab_reg(reg);
	//printf("\n\n");
}
